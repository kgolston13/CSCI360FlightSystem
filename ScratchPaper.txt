Airport: CYVR
  -> Neighbor: CYYZ, Distance: 3345.493166632615
  -> Neighbor: KATL, Distance: 3611.705340346166


CYYZ -> KJFK 588.5438781875994
KJFK -> CYUL 537.102266241723
CYUL -> CYYZ 507.2391234907016


    public List<Airport> searchForShortestFlightPath(Airport startingAirport, Airport endingAirport,
            double maxDistanceBetweenNodes, String fuelTypeOfPlane) {
        // Check if either starting or ending airports are null
        if (startingAirport == null || endingAirport == null) {
            System.out.println("Invalid airports provided.");
            return null;
        }

        // Create a map to keep track of visited airports
        Map<Airport, Boolean> visited = new HashMap<>();
        for (Airport airport : airports) {
            visited.put(airport, false);
        }

        // Create a queue for BFS
        Queue<List<Airport>> queue = new LinkedList<>();
        List<Airport> path = new ArrayList<>();
        path.add(startingAirport);
        queue.offer(path);

        while (!queue.isEmpty()) {
            path = queue.poll();
            Airport lastAirport = path.get(path.size() - 1);

            // If the last airport in the path is the ending airport, return the path
            if (lastAirport.equals(endingAirport)) {
                return path;
            }

            // Check if the airport has been visited, if not, mark it as visited
            if (!visited.get(lastAirport)) {
                visited.put(lastAirport, true);

                // Get all neighboring airports
                List<Airport> neighbors = getNeighbors(lastAirport, maxDistanceBetweenNodes, fuelTypeOfPlane);

                // Add neighbors to the queue
                for (Airport neighbor : neighbors) {
                    List<Airport> newPath = new ArrayList<>(path);
                    newPath.add(neighbor);
                    queue.offer(newPath);
                }
            }
        }

        // If no path is found
        System.out.println("No path found with current parameters.");
        return null;
    }

    // Helper method to get neighboring airports within the maximum distance
    private List<Airport> getNeighbors(Airport airport, double maxDistance, String fuelTypeOfPlane) {
        List<Airport> neighbors = new ArrayList<>();
        AirportNode node = airportGraph.get(airport.getICAO());

        // Iterate through neighboring airports
        for (Map.Entry<AirportNode, Double> entry : node.edges.entrySet()) {
            AirportNode neighborNode = entry.getKey();
            Airport neighborAirport = neighborNode.getAirport();
            double distance = entry.getValue();
            if (distance <= maxDistance && neighborAirport.getFuelType().equalsIgnoreCase(fuelTypeOfPlane)) { // FuelTypeComparator
                neighbors.add(neighborNode.getAirport());
            }
        }

        return neighbors;
    }